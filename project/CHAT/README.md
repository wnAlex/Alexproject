# Alexchatserver
基于nginx负载均衡的聊天服务器和客户端

项目介绍：这是一个基于muduo网络库的集群聊天服务器项目，项目采用软件代码分层设计的思想，主要包括三个模块，分别是网络层，业务层和数据存储层，网络层采用muduo库，这是一个开源的c++网络库，可以支持较好性能的高并发，同时将网络代码与业务代码分离，可以更好地专注于业务代码的开发，业务层进行网络类和业务类的分离，主要使用bind绑定器和map表实现回调机制，网络层的消息请求通过解析获取json对象的消息id，然后通过回调处理消息，通过网络类和业务类的回调分离，使得业务层代码具有良好的可扩展性，数据存储层采用mysql进行项目相关信息的存储，主要包括用户密码，好友列表，群组列表，离线消息等，单机服务器的基本模块就是这样，同时为了更好的支持高并发和服务可拓展性，进行了服务器的集群设计，集群设计主要需要解决两个问题，一个是负载均衡，这里采用Nginx的tcp负载均衡模块进行负载均衡的设计，另一个是不同用户会注册在不同服务器上，需要实现用户跨服务器聊天，这里采用基于发布订阅的redis作为MQ消息队列进行消息的分发，实现跨服务器的消息通信。
 

1.文本文件和二进制文件的区别

​   无论是文本文件还是二进制文件，其最终的物理存储方式都是相同的，都为01串，区别在于逻辑存储方式，即编码方式的不同，二进制文件是不定长编码，文本文件时定长编码，如int i =1 ，将i写入二进制文件，其最终保存的为0x 0000 0001(4字节)，而将i写入文本文件，最终保存的时'1'这个字符的ASCII码值，为一个字节。  其在内存中的01串都是4字节的（都是int），但在文件中不一样，写入文本文件需要做一步转换，而写入二进制文件就是直接的从内存拷贝。

2.序列化和反序列化的作用

​   就二叉树的序列化和反序列化而言，序列化就是按照先序遍历方式以及“#”字符拼接将二叉树转化为一个字符串保存在磁盘上，反序列化就是从磁盘读出这个字符串，然后将其按照先序遍历和“#”字符分割的方式转换为一个二叉树，此处的先序遍历和“#”字符分割就可以当作双方协议规定的内容，
    序列化和反序列化就是数据发送和接受双方根据传输数据的格式生成一个协议，所以所谓的序列化就是按照协议规定的格式进行数据的封装，反序列化就是根据协议进行数据的解封。可以保证发送方打包的数据经过传输后，接收方能够顺利的从数据包中提取出数据

​	将数据传递个json对象就好比在建立一个个的二叉树结点，然后json对象会调用dump函数进行对象成员的封装，封装成一个json字符串在网路上传递后，对端接收到json字符串，也会根据json规定的协议进行解析，得到相应的json对象，然后就可以从json对象中正确取出传递的值了。序列化不是告诉你对端传了哪些数据，这是你们之前都知道的，序列化只是保证这些数据传过来不是乱码，能进行分割后保证你能正确的拿到这些数据。即只保证json对象->json字符串，json字符串->json对象

3.cmake
    最初编译文件都直接用gcc命令，但随着源文件数量增加，gcc每次都要重复输入且所有源文件都必须重新编译，费时费力，后续引入了makefile，先生成源文件对应的目标代码文件，最后一起链接生成可执行文件，解决了上述问题，但是makefile书写还是太复杂，故引入了cmake用来自动生成makefile,其主要就是对于gcc命令参数的封装。
    gcc -o main -g main.c a.c -I -L -l -i 
4.内存分区
c++程序运行时，分为以下几个区域
    代码区：存放函数体的二进制代码,由os管理分配与释放
    全局区/静态区（static）：存放全区变量，静态变量和常量，可细分为.data段和.bss段,初始化的全局变量和静态变量和常量在.data段，未初始化或初始化为0的全局变量和静态变量在相邻的.bss段，由os管理分配与释放
    栈区（stack）：存放函数的参数值、局部变量值等，由编译器自动分配释放
    堆区（heap）：存放用户动态申请的数据，由程序员分配释放，若程序员不释放则程序结束时可能由操作系统回收
    
    程序编译生成可执行程序后，未运行前存储在磁盘中，该文件有两个重要的区域，即代码区和全局区。
    代码区存在程序的二进制代码。
    全局区存放全区变量，静态变量和常量，可细分为.data 段 和 .bss段，其中.data段存储已初始化的全局变量，静态变量，常量，.bss 段存储未初始化或初始化为0的全局变量，静态变量。

5.c++静态变量初始化时机
    静态变量分为全局静态变量（又称全局变量）、局部静态变量（函数中的静态变量）和类中静态成员变量。按照初始化的类型分为静态初始化（static initialization）和动态初始化(dynamic initialization)。
    1.静态初始化
    static initialization：指的是用常量来对静态变量进行初始化，包括zero initialization和const initialization，
    常量初始化会在编译阶段分配内存，同时初始化，生成可执行程序保存在磁盘时，其.data段就已经有了相应的初始值，程序加载时只需将其映射到内存空间即可
    0初始化生成可执行程序保存在磁盘时，.bss段不会占用实际磁盘空间，只是做了标记，当程序加载到内存时便会为静态变量分配内存并初始化为0。
    c语言采用这种方式

    可执行文件--->加载到内存中---->运行代码

    2.动态初始化
    c++引入了面向对象，还可以采用动态初始化
    dynamic initialization：动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：int a = foo()，或者是复杂类型（类）的初始化（需要调用构造函数）等。对于全局或者类的静态成员变量，是在main()函数执行前由运行时调用相应的代码进行初始化的。而对于局部静态变量，是在函数执行至此初始化语句时才开始执行的初始化。
   
6.C++在new时的初始化的规律为：
    1、对于有自己写构造函数的类，不论类型名后面有没有括号，都用构造函数进行初始化；
    2、如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，
    3、而加了括号的new会在分配内存的同时初始化为0。
7.单例模式
    为什么需要单例模式？
        某些情况下要求全局只有一个唯一的实例对象，这在某些场景下是很有必要的，比如任务管理器，数据库连接池等，多个对象只是对资源的浪费且没有意义，我们可以用全局对象的方式实现对应的功能，但是终归无法保证全局只有一个唯一的对象（比如可以在其他地方创建），故需要引入单例模式
    单例模式如何实现？ 
        单例模式需要私有化构造函数，类内完成全局唯一实例的构造，并向外提供一个访问全局唯一实例的接口函数，并且要考虑线程安全问题。一般的实现方式有两种：
        1.懒汉模式：单例实例在第一次使用时才初始化，会存在内存泄露和线程安全问题，
        内存泄露是因为静态成员变量指针无法合理的释放，可以通过内嵌私有类和用智能指针解决，
        线程安全问题是因为静态成员变量在动态初始化，可能多线程同时进行判断if(ptr==null)，从而创建了多个单例对象，造成错误，可以通过双检测锁DCL解 决。（DCL保证了只是在第一次获取实例的时候加锁，后续不会再有加锁的开销）
        2.饿汉模式：单例实例在程序载入内存后，运行main函数之前初始化好，也即main函数之前的单线程启动阶段，故不存在线程安全的问题。但C++没有规定多个静态成员对象的初始化顺序，尤其是来自多个编译单元的静态成员对象，他们的初始化顺序是随机的。可能潜在静态成员函数返回instance时instance这个静态成员还未初始化好。且耗费空间，是一种以空间换取时间的方法，且仍需要解决内存泄漏问题。 
    采用静态局部对象方式设计是最好的，对于local static 对象，其初始化发生在控制流第一次执行到该对象的初始化语句时。多个线程的控制流可能同时到达其初始化语句。在C++11之前，在多线程环境下local static对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行local static对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生内存泄露问题。但C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。且不存在内存泄露（很好的解决了线程安全和内存泄露的问题）
8.数据库分层设计
    项目中对于mysql开发包中的函数进行了进一步的包装，但仍需要传入sql语句，这在业务层面显然是不好的，因此采用了ORM的设计思想，为每一个表设计一个ORM类封装表的字段作为属性，同时再为每个表设计一个model类，封装对于每个表的对应的操作，从而实现在业务层面都是面向对象编程，不会出现sql语句和表的字段属性信息。
    ORM类作为参数传入给model类，model类组装对应的sql语句后调用db类，然后model类将db类返回的结果（字段属性）封装成ORM类返回，这样外界只看到ORM
    假设返回用户的离线消息，根据客户端发来的userid，封装offlinemessage对应的ORM类，传入model类方法中，然后model组装对应的ORM类返回，然后序列化发送给客户端
    其中再返回用户群组信息时，按道理来说可以在按照上述流程返回对应的用户群组信息，但业务需要返回群组中的成员信息，故ORM类中加入了群组成员数组，且由于群组成员和user不完全一样，且只是比user多一个role字段，故直接继承user，

9.项目整体流程
    服务器：
    客户端发送命令请求，网络层解析得到json对象，然后根据msgid调用不同的回调函数，回调函数中，如果需要访问数据库，就先根据客户端传来的数据（userid等）封装给对应的ORM对象，然后传入model类的函数中去，model类组装sql语句，调用mysql函数，并接受msql返回结果，然后将返回的结果字段属性组装成ORM对象返回给回调函数，回调函数根据返回结果做进一步处理，然后序列化json对象，发送给客户端。
    客户端：
    首先建立连接，连接成功后开启子线程负责接收数据，同时主线程负责发送数据，然后主线程发送登陆消息，并在信号量上等待，之后子线程接收到登录ACK后进行解析，并操作全局变量bool值，然后唤醒信号量，主线程根据bool决定是否登陆成功，登陆成功后进入聊天页面，解析用户输入的命令，然后调用hashmap中对应的回调操作，封装相应json对象，发送给服务器

10.多核多cpu区别，并发并行的概念是最基础的
    并行：同时执行 并发：交替执行
    1、单CPU中进程只能是并发，多CPU计算机中进程可以并行。
　　2、单CPU单核中线程只能并发，单CPU多核中线程可以并行。
　　3、常说的四核八线程，四核就是指上文的四个cpu，八线程就是上文的八个核心
由此引出了多进程编程和多线程编程
    (进程线程都是需要考虑同步和通信问题)信号量强调的是线程（或进程）间的同步 互斥锁(又名互斥量）强调的是资源的访问互斥
    多进程主要考虑进程间通信：管道，套接字，共享内存，消息队列
    多线程主要考虑共享数据的竞态条件和缓存问题(也就是线程间通信问题)
    两者还都需要考虑同步问题，信号量（进程，线程） 条件变量（线程）
11. A:  多线程可能同时访问修改共享变量的时候，一定要加锁,如chatservice::usermap
        多线程只读共享变量不需要加锁,如chatserveice::hanldermap
        多线程不同时访问修改共享变量的时候，不存在竞态条件，可以不加锁，如客户端的g_isLoginSuccess,但需要加volatile关键字，保证每次访问线程都从新从内存读取数据，避免出现线程缓存问题
    B:多线程编程存在两个问题
        1.竞态条件问题:当多个线程同时读取共享对象时，不会出现线程安全问题，如chatserveice::hanldermap
                      当多个线程同时修改共享对象时，由于cpu的调度问题（register++），会导致出现线程安全问题，需要通过加锁来解决
                    锁就引入了硬件那一部分知识
        2.缓存问题：当多个线程不会同时修改共享对象（可通过信号量保证）,就不会出现竞态问题，但是要考虑缓存问题，缓存可能导致某个线程用的一直是旧的错误的值， 采用volatile修饰可以解决缓存问题，每次都会重新从内存读取数据，防止编译器优化。但volatile无法解决竞态问题。还是可以两个线程同时重新从内存读数据，然后修改出错。
    C:哪怕cpu有缓存一致性，还是需要volatile关键字，为什么？
             MESI只是保证了多核cpu的独占cache之间的一致性，但是cpu的并不是直接把数据写入L1 cache的，中间还可能有store buffer。  
    D:为什么有了信号量，还要条件变量
        1.两者都是进程或线程间同步工具，保证合理有序的推进
        2.条件变量一般用于线程间，信号量可以进程间，可以线程间
        3.如果用信号量，当wait(s)的时候，默认了“我使用s，并且根据情况判断是否等待s”。但如果用条件变量，就只有一个语义，就是“我等待s”，而并不必须使用s(我上面的例子，在后续是value--，这其实就是使用value。当然也可以是干一些别的。而如果用信号量，那么wait(s)里已经默认了value--)。这应该是最大的不同。
    E:条件变量cond_wait之前先加锁，然后进入函数内部解锁后线程马上进入阻塞，等待条件满足，其他线程此时可以获取锁，修改对应变量，然后当条件满足就con_notify阻塞的主线程，主线程唤醒后，先获取锁，然后返回，进行后续操作。
        条件变量必须和互斥锁一起用，因为不加互斥锁，可能主线程调用cond_wait时还未进入wait状态（未挂载到wait queue中去），然后子线程就开始singal唤醒，则此时主线程并不会被唤醒，后续主线程就一直阻塞了。用了互斥锁可以保证主线程必须进入wait状态后（wait函数中释放锁和进入wait状态是原子的）子线程才可以获取锁，然后修改变量唤醒主线程。如果主线程条件满足，那肯定不需要wait，就直接往下走了，条件变量也就不需要工作了，上面讨论的肯定都是主线程条件不满足需要阻塞的情况。
12.为什么要对redis发送命令的函数进行拆分调用?（为何需要另起一个线程去接受redis server返回？）
        因为publish是一个非阻塞的过程，而subuscribe是一个阻塞的过程，publish直接调用发送命令的函数，发送命令函数会调用三个函数，先将命令缓存到本地，然后发送到reids server，然后等待redis server返回，这是没有问题的，但当调用subscribe时，当前线程阻塞在等待返回上，所以必须另起一个线程，主线程负责牵连个函数调用，接收线程负责最后的接收函数的调用  
        哪有几个线程就只能调用几次subscribe了，muduo一般就三个worker线程。所以将其分开，publish用publish上下文，subscribe和unsubscribe用subscribe上下文，同时subscribe上下文不能直接调用redis发送命令的函数，必须分解开来，然后另起一个线程去接受redis server的返回。
    为何需要两个redis上下文？
        subscribe上下文中不可以输入类似pubulish的命令了。
    redis工作流程？
        redis类封装了两个redis上下文和相应的读线程，以及subscibe，unsubscribe，publish函数，当用户登录时，服务器会调用subscribe()向redis注册，下线时会调用unsubscribe()向redis取消订阅，然后当服务器需要转发消息，在自己的map中找不到对应连接，但访问数据库发现用户在线时，就会publish(),然后redis负责转发消息。对方读线程接受到消息后，调用回调进行消息的处理。
13.如何解决消息的传输安全问题？
    首先，消息明文在网络上传输的话肯定是不安全的，需要采用一定的加密算法，目前常用的加密算法有对称加密和非对称加密，对称加密双方共享密钥，效率较高，但存在密钥分发的问题，非对象加密双向各自持有公钥和私钥，效率较低，所以可以选择的方式是当客户端与服务器建立连接后，先通过非对称加密进行密钥分发，然后服务器端存储相应密钥，后续再次接收到客户端发送来的消息时，用密钥进行解密即可。
14.如何保证消息按序显示？
    首先考虑采用时间戳，用户A发送消息时都会加上时间戳，服务器直接转发消息给用户B，用户B客户端接收到消息后，不直接显示，采用固定的时间间隔对接受的消息根据时间戳排序后进行显示，会存在问题，当消息之间抵达的先后间隔超过缓存的固定间隔后，仍会存在乱序显示问题。
    可以采用序列号，用户A保存其好友B的一个unsigned int类型的序列号，每次给B发送数据都会将序列号++，服务器只负责转发数据，用户B保留其好友A的一个序列号，每接受一条A发过来的信息，就与序列号核对是否一致，如果不一致，先缓存，如果一致就直接显示，序列号++，然后检查缓存中消息是否满足序列号，满足继续显示。
    群组消息也是一样，用户A保存群组C的一个序列号，每次在群组中发送消息都会将该序列号++，然后服务器转发消息，群组中其他成员如B会保存该群组对应成员每个人一个单独的序列号，当接收到群组消息时，会判断群组C中用户A序列号和其消息中序列号是否一致，不一致就缓存，一致就显示，然后查看缓存继续显示，等于用户B要单独保留一个用户A的序列号seqA，和群组C用户A的序列号seqCA.
    同时有了序列号之后可以实现撤回操作，用户A撤回某个消息发送给服务器，服务器转发给B，B客户端根据A撤回消息中携带的序列号将对应消息从显示页面删除，有了序列号才可以表示某一个具体的消息。
15.服务器端如何感知客户端下线了？客户端也可以检测服务端可否联通
    当网络状态正常时，客户端下线会主动进行TCP四次挥手，最后服务器端接收到客户端的ACK消息，客户端time_wait后，服务器端和客户端正常下线，清理各自资源。
    但如果网络十分拥塞，可能最开始服务器端都收不到客户端发送的fin包，多次重传后仍未收到那么客户端就自动下线了，但是服务器端无法感知客户端下线了，此时想到有两个层面的解决方式
    1.传输层：采用TCP的keepalive机制，在服务器端生成相应socket时，setsocketopt中keepalive参数，则每隔固定一段时间，服务器端会给客户端发送一个空报文段，检测客户端是否在线，如果未收到回复，则会以一定的间隔连续发送一定次数，都未成功收到回复则表明客户端已经下线，就拆除传输层的连接资源，释放socketfd，但是这种方法有两个问题，一是它处在传输层，如果检测到下线只会释放传输层的资源，但业务层还有相应类似保存链接的map也需要释放资源，他做不到，第二个是如果客户端业务层代码发生类似死锁，但其传输层仍可以进行保活确认，相当于c——s双方传输层可以交互，但业务层已经出问题了，实现不了业务层的保活。
    2.应用层:采用心跳机制，服务器端用一个udp套接字监听相同端口，同时服务器端为每一个conncet成功的客户端分配一个心跳计数，每隔1s固定时间加一，客户端采用udp套接字向服务器每隔1s间隔发送一个heartbeat报文，同时客户端也有有一个心跳计数，每隔1s固定时间加一，收到服务器对于heartbe的相应报文就-1，当客户端超过5就表示客户端连接不上服务器了，就显示离线，就需要重新登陆，服务器udp套接字接收到相应报文后解析获取客户端连接，然后将对应连接的心跳计数-1，当心跳计数最终超过5时，就在服务器端删除对应链接，然后清除其他资源。
16.如何保证数据的可靠传输？仅仅依靠TCP协议可以吗？
    当调用send函数发送数据时，将用户缓冲区数据成功拷贝到内核TCP发送缓冲区后，send函数就开始返回，后续TCP开始进行可靠数据传输，发送数据后等待服务器端的ACK相应，如果一段时间后没有收到ACK，便开始超时重传，但是如果网络状况十分拥塞，超时重传失败了一定次数后，便后发送RSt报文，重置连接,放弃tcp流。这样的话无法保证消息一定成功发送到对端。而此时客户端上层感知不到，看到send成功返回就以为ok了，所以需要实现一个机制保证消息可靠传输，同时哪怕没有发送成功客户端也应该知晓。
    后来想了想可不可以TCP提供一个重传失败回调供用户调用，后来想了想不可以，因为一方面用户态无法访问内核态，另外TCP是所有应用都要用的，你一个应用改了回调，其他应用都会调用这个回调，肯定不行。
    所以应该在应用层实现类似可靠数据传输的机制，客户端每条信息都有相应序列号seq，当发送数据时，现在用户态申请一个缓存，将数据放入缓存中，然后发送，并等待服务器的相应MSG_ACK,接收到相应ACK后将数据从缓冲区删除，如果超过一定时间未接收到相应，便开始重新传送消息，同时如果超时了一定次数都发送失败，可以在客户端显示发送失败，由用户选择重新发送。
17.历史消息的存储问题
    历史消息可以选择存储在本地，也可以选择储存在云端
    存储在本地的话可以消息存储在文件中，以账号的方式组织文件来存储和个人以及群组的聊天消息，但是不好查询和检索且换了机器后就无法获取了，故可以考虑采用sqlite嵌入式数据库，但没有具体采用这种方法
    采用的是云消息存储方法，在mysql中根据用户id建立对应的表，当客户端A给客户端B发送消息，服务器在转发消息给B并且成功收到ACK后，将消息存储在mysql中。
18.为什么引入服务器中间件，redis的不稳定性有哪些？
    当采用集群服务器设计的时候，可以采用硬链接，硬链接会带来很多问题，一方面每个服务器既要做客户端，又要做服务器，需要不断和其他服务器利用心跳机制交互，开销十分巨大，另一方面整体耦合度太高，拓展性太差，当拆除或者新增服务器过程过于繁琐
    redis作为中间件，一是转发消息时如果找不到channel，就直接丢弃消息，另一个是转发了就不问了，不保证可靠数据传输，