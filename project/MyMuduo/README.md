1.实现一个线程安全的类是容易的，只需要让类内部保有相应的mutex，然后在成员函数中访问成员属性时用mutex构造相应的临界区即可，这样当对象在多线程中被同时访问时，也不会出现线程安全问题，但是这只是保证了对象活着的时候其内部属性的线程安全，没办法用内部mutex保证对象自身的生命周期。
    对于构造函数而言，安全就是要保证构造函数执行过程中不对跨线程对象或这外线程泄露自己的this指针，因为这样，可能导致当前对象在本线程尚未构造完毕，其他线程就调用本对象的成员函数，造成难以预料的后果。因此二段式构造是合理的，第一段构造在构造函数中完成内置变量的初始化，第二段构造initiallize()中完成相应资源的获取，构造函数自身不抛出异常，通过二段方法返回值判断对象是否构造成功
    对于析构函数而言，最重要的问题就是假设一个对象是堆区或者全局区，即所有线程可见的，保证不出现其他线程调用对象成员函数的时候，当前线程已经把对象析构了。要实现跨线程监听对象生存状态的机制，采用智能指针解决。用mutex来保证调用其他成员函数时，不会调用析构函数不可取，可能析构先获取锁，然后对象释放，锁失效，其他线程还卡在成员函数的锁上，不知会发生什么。再退一万步，析构本来就不应该需要保护，析构的意思就是没有任何人再用他了，所以才会析构，出现安全问题就是因为还有人再用他，我就把他析构了。
    0.当前线程访问一个对象的成员函数时，另一个线程把当前对象析构了，可以让当前线程持有一个指向该对象的强sp，或者弱sp（lock后使用）
    1.A类调用B类提供的设置回调函数的接口，给B类中函数类型的成员赋值，然后当前线程执行B类对应的回调函数时，A类对象已经其他线程被析构了，此时就会发生错误，可以让B类持有一个指向A类的强智能指针（通过设置回调时bind传入：shared_from_this()在B类对象的函数类型的成员变量中保留一个A类对象的强sp），这样就不会当B类对象调用A类对象成员方法时，A类对象已经被析构了，但这样会强行延长A类对象生命周期，故采用弱回调，B类对象保留A类对象的弱智能指针，当需要调用A类方法时，先lock（），如果成功就调用，不成功就不调用。
    2.Observer模式：A线程创建一个observer派生类对象，B线程创建一个observerable对象，当不用智能指针，observer对象调用observable对象成员函数注册在其map中，然后obable对象监听到对应事件，就调用map中obver对象成员方法，此时可能A线程已经析构了对应对象，此外，如果observer对象在A线程析构时调用obable对象的成员方法，可能B线程已经析构对应对象，采用智能指针后，A线程创建sp对应的observer对象，B线程创建sp对应的observerable对象（之前都是new出来的），然后observer对象调用observable对象成员函数注册在其map中，此时observer对象内保有observable对象的弱sp，observable对象map内存有observer的弱sp，当彼此调用时可以通过指针lock(),然后根据结果确定彼此生存状态。
    3.对象池：对象池类提供get（）接口获取对象，如果返回正常指针，可能在多线程情况下存在析构竞态条件，故要返回强sp，同时对象池内map保留弱sp，为了保证对象析构后从对象池map中删除，可以在get（）方法中创建对象强sp时指定析构时对应的destructor，并传入对象池内部函数，为了保证对象析构时对象池还在，要传入对象池的强sp，但是直接传入shared_ptr<对象池>(this),会生成两个独立的引用计数，故需要引入ennable_from_this,其内部有一个弱sp，当创建对象池强sp时绑定在对象池上，然后调用share_from_this(),会将指向对象池的弱splock（）后返回，其要求必须先构造对象池，然后构造对象池的强sp。
    对于Observer和对象池而言，A对象创建成功后需要注册在B对象对应的map表中，然后B发现A感兴趣的事件发生了，B对象访问map表调用A对象的成员方法，会存在调用时A对象已经被其他线程析构了，所以采用map表中存储A对象的强sp，这样会造成A对象一直不释放，故采用弱sp，调用前先lock判断，然后A析构后需要调用B对象的方法将自己从B对象map中删除，此时可能出现B对象已经被析构了，故A对象需要保留B对象的弱sp，或者将B类做成单例模式。
    主要就是解决多线程情况下，当类内部成员变量为另一个类对象的指针时，如何跨线程监听该对象的生存状态。
2.空悬指针：指向已经销毁的对象或者已经回收的地址
    野指针：指向未初始化的地址
3.同时读写一个线程安全类的两个对象，可能存在死锁问题，如线程1swap(a,b),线程2swap(b,a);
    为了保证按照相同的顺序加锁，可以比较mutex对象的地址，始终先加锁地址较小的mutex。
4.智能指针解决对象的生命周期管理，但是不管理对象内部属性的线程安全问题，这个有对象内部mutex保证。同时智能指针对象自身也不是线程安全的，当有一个全局的智能指针时，访问或者修改智能指针指向是需要加锁的。一般智能指针都是线程自己栈上的。
5.C++内存问题大概有：缓冲区溢出（用vector类设置或者自己写buffer类管理缓冲区）
                    空悬指针/野指针/重复释放/不配对的new delete/内存泄漏(用sp)
                    内存碎片()
6.RAII：资源获取即初始化，即每一个明确的资源配置动作都应该在单一的语句中执行，并在该语句中立刻将配置获得的资源交给handle对象（如智能指针），通过栈上对象自动析构的特点管理资源，
7.智能指针存在循环引用的问题和强行延长对象生命周期的问题，A类有B类成员对象的智能指针，B类有A类成员对象的智能指针，这样当A，B类各自生成对象并初始化后，存在循环引用，无法释放的问题，需要A类持有B类的强sp，B类持有A类的弱sp  
8.裸指针到底有什么不好，写过一些C++代码的人应该都能知道，比如下面的原因：空悬指针/野指针/重复释放/不配对的new delete/内存泄漏(用sp)
    忘记释放资源，导致资源泄露（常发生内存泄漏问题）
    同一资源释放多次，导致释放野指针，程序崩溃
    明明代码的后面写了释放资源的代码，但是由于程序逻辑满足条件，从中间return掉了，导致释放资源的代码未被执行到，懵
    代码运行过程中发生异常，随着异常栈展开，导致释放资源的代码未被执行到，懵
9.智能指针：不带引用计数的智能指针：
            1.auto_ptr:不私有化拷贝构造和拷贝赋值，只有最后一个auto_ptr持有资源
            2.scoped_ptr:私有化拷贝构造和拷贝复制，不允许资源转移
            3.unique_ptr:私有化拷贝构造和拷贝复制，不允许资源转移，但unique_ptr提供了带右值引用参数的拷贝构造和赋值，
            带引用计数的智能指针：
            1.shared_ptr:允许多个智能指针指向同一个资源的时候，每一个智能指针都会给资源的引用计数加1，当一个智能指针析构时，同样会使资源的引用计数减1，这样最后一个智能指针把资源的引用计数从1减到0时，就说明该资源可以释放了。shared_ptr和weak_ptr底层的引用计数已经通过CAS操作，保证了引用计数加减的原子特性，因此shared_ptr和weak_ptr本身就是线程安全的带引用计数的智能指针。
                private:
                    /*
                    下面这两个是shared_ptr的成员变量，_Ptr是指向内存资源的指针，_Rep是
                    指向new出来的计数器对象的指针，该计数器对象包含了资源的一个引用计数器count
                    */
                    element_type * _Ptr{nullptr};
                    _Ref_count_base * _Rep{nullptr};
                    这个RefCount对象有两个引用计数，一个shared_ptr的计数，一个weak_ptr的计数。当shared_ptr的引用计数为0时，释放资源，当shared_ptr和weak_ptr的计数都为0，才释放RefCount对象。

            2.weak_prt:weak_ptr不会改变资源的引用计数，只是一个观察者的角色，通过观察shared_ptr来判定资源是否存在
                weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数
                weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源
10.为何建议用非重入的互斥锁？
    非重入和重入的互斥锁都是可以保证不同线程间的共享访问安全问题，但是对于同一线程之间，假设post()修改变量，traversl()访问变量，都是线程安全的方法，都会加mutex保护临界区，当traversal调用post时，即同一线程访问变量的时候还修改了变量时，如果是可重入锁，会出现问题，如果时不可重入锁，会报错不让代码执行，假设post用写锁，traversa用读锁，在travesal中调用post，如果读锁可升级为写锁，还是会程序出问题，如果不可以升级，则报错。
    当遇到这种情况，解决方式一是将修改退后，先访问，在修改。第二种方式是使用sp做copy-on-write，当要读共享对象时，用一个sp重新指向共享对象，当要写共享对象时，看对象sp引用计数，如果为一，直接修改，如果>1,则重新申请一个sp指向新一块内存，将原对象拷贝过来，然后修改。
11.多线程编程的优势，实现异步编程，提升cpu利用率，降低延迟和响应时间。 
    开启多个线程执行一个任务不能减少工作量，即不能减少cpu运行时间，但是可以通过合理调配任务在多个线程上同时运行，让任务提前结束，降低程序响应延迟。
    所以多线程程序没办法提升并发连接数：thread per connnction 还没单线程基于IO复用的并发连接数高
    多线程程序也没办法提高吞吐量：一个任务0.8s，在8核cpu上，单线程跑0.8s，同时开启8个单线程任务也需要0.8s完成8个任务，如果多线程编程，把0.8s分给8个线程同时做，0.1s就结束第一个任务，但8个任务8核总共还是需要0.8s，只不过说好处是多线程反应快，延迟低，0.1s第一个任务就做完了。
    多线程任务可以降低响应时间：一方面如上面所说，另一方面假设一个线程需要访问数据库，可以用单线程去做同步等待，也可以另起一个线程去访问数据库，然后当前线程直接返回响应，不需要等待访问数据库的返回。在客户端看来就感觉是服务器的相应变快了。
12.pthread库提供了pthread_self函数返回当前线程的标识符，类型为pthread_t,但是这个值只能保证同一进程内，同一时刻的各个线程的id不同，无法保证同一进程先后多个线程具有不同的id，更不要说多个进程之间的id唯一性。因此一般才哟个gettid(),返回类型为pid_t，直接表示内核的任务调度id，可以调用后保存在__thread变量中。
13.__thread关键字是线程局部存储设施，可以用来修饰全局变量和静态变量，其表示每个线程有一份独立实体，各个线程互不干扰。也只能修饰POD类型。
14.为何服务器端程序不应该关闭标准输出和标准错误？
    因为某些第三方库会调用stdout或者stderr打印信息，如果关闭了fd=1，和fd=2，那么这两个fd可能被其他网络连接使用，那么第三方库调用时就会把打印信息发给对端，应该是把stdout和stderr重定向到磁盘文件。
15.多线程和fork()兼容性很差，因为fork（）只会克隆当前线程的信息，当前进程的其他线程信息都不会克隆，都消失了
16.为何c++库中好多类不是线程安全的？
    一方面是为了避免不必要的性能开销，另一方面类提供的单个函数保证线程安全的情况下，成员函数的线程安全不具备可组合性，如std::cout<<"aa"endl;会调用两次左移运算符重载，即使左移运算符重载做到了线程安全，可能在当前线程输出完“aa”后其他线程获取锁，进行输出，然后当前线程在输出endl；

1.什么是阻塞，非阻塞，同步异步？
    阻塞非阻塞，同步异步都是描述Io的状态，一次正常的IO包括两个阶段，数据准备和数据读取阶段，数据准备阶段可以分为阻塞和非阻塞两种，以recv为例,当socket为阻塞时，recv会阻塞不返回，当socket为非阻塞时，recv调用后socket没数据也会直接返回，可以根据返回值进行判断，如果返回-1&&errno=EAGAIN，说明正常非阻塞返回，如果只是-1，说明出错，返回0说明对端关闭连接，返回>0代表读取数据的大小。
    当数据准备完成后，就开始数据的读取阶段，对于recv而言是同步的，需要自己将数据从os内核缓冲区搬到用户的buf中，对于异步IO而言，则需要在调用的时候，告知其scoket，buf和通知方式，其主动在内核线程中帮我们把数据办好，然后以约定好的通知方式告诉调用者，调用者不需要自己去办运数据。在业务层面也经常说同步异步，同步就是A函数调用B函数，需要等待B函数执行完毕才可能继续往下执行。异步调用是指A函数调用B函数，并告诉B函数感兴趣的事件和通知方式，然后A函数继续执行，B函数在监听到A感兴趣的事件后通过约定好的通知方式通知A函数，一般是回调。
    举例A函数需要123读数据库567共7个步骤，同步就是A函数线程每次都阻塞在读数据库上，如果异步就是A只做123，然后让另一个线程去做都数据库，并绑定回调，回调中再去做567，在单线程中，同步异步没啥区别，多线程中，同步的话会让执行A函数的线程在调用B函数时，线程2执行B函数，但是线程1却必须等B函数返回才能继续执行A函数，这就不对了，异步可以让AB同时执行。
        常规模式：调用完S服务后后我去执行X任务，
        回调模式：调用完S服务后你接着再去执行X任务，
2.linux五种IO模型
    同步阻塞：数据准备阶段，如果没有数据就阻塞，有数据就直接返回，数据读取阶段，都需要当前线程自己去将数据从OS内核读到buf中
    同步非阻塞：数据准备阶段，如果没有数据就直接返回，根据返回值做判断，数据读取阶段，需要当前线程自己去将数据从OS内核读到buf中
    IO复用：数据准备阶段，通过select/poll/epoll监听多个套接字，有数据就返回，无数据可以阻塞或者timeouts后返回，数据读取阶段需要当前线程自己去读取数据
    信号驱动：数据准备阶段是异步的，通过向OS注册信号，然后当前线程继续执行，当有数据了会通知当前线程进行数据读取，数据读取仍需要当前线程自己来做
    异步非阻塞:向OS注册相应感兴趣的事件和通知方式，然后当前线程继续向下执行，当有数据了之后，OS会将数据读到buf中然后告知当前线程去处理数据。
3.IO复用需要配合非阻塞socket，因为当epoll返回可读事件，如果是LT模式，需要一直读一个fd，肯定会读到阻塞，所以必须将fd设置为非阻塞，如果是ET模式，只读一次，按道理不会阻塞（因为就是有数据才会返回），但可能存在上层协议检查到这个数据有误，将其丢弃，那么此时就会阻塞。